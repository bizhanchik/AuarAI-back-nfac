# AuarAI iOS App - Cursor Rules

## Project Overview
AuarAI is an AI-powered wardrobe management and outfit recommendation iOS app. Users upload photos of their clothing, AI classifies the items, and provides personalized outfit suggestions based on weather, location, and occasion.

## Core Technologies & Requirements
- **Minimum iOS version**: iOS 16.0
- **UI Framework**: SwiftUI
- **Concurrency**: Modern Swift Concurrency (async/await, actors)
- **Architecture**: MVVM with Repository Pattern
- **Navigation**: NavigationStack (iOS 16+)
- **Networking**: URLSession with async/await
- **Image Processing**: Vision Framework for local classification
- **Location**: CoreLocation for weather and location-based recommendations
- **Camera**: PhotosPicker and Camera for wardrobe photo capture

## File Structure & Organization Rules

### Directory Structure
```
AuarAI/
├── App/
│   ├── AuarAIApp.swift
│   └── ContentView.swift
├── Core/
│   ├── Models/
│   ├── Services/
│   ├── Repositories/
│   └── ViewModels/
├── Features/
│   ├── Authentication/
│   ├── Wardrobe/
│   ├── OutfitRecommendation/
│   ├── Weather/
│   └── V2VAssistant/
├── Shared/
│   ├── Views/
│   ├── Extensions/
│   ├── Utilities/
│   └── Constants/
└── Resources/
```

### Naming Conventions
- **Files**: PascalCase (e.g., `WardrobeView.swift`, `ClothingItemModel.swift`)
- **Classes/Structs**: PascalCase (e.g., `WardrobeViewModel`, `ClothingItem`)
- **Properties/Variables**: camelCase (e.g., `clothingItems`, `isLoading`)
- **Functions**: camelCase (e.g., `fetchClothingItems()`, `classifyImage()`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `API_BASE_URL`, `MAX_IMAGE_SIZE`)

## Modern Swift Concurrency Rules

### Service Classes
```swift
// ✅ Good - Use actor for thread-safe services
@MainActor
final class ClothingService: ObservableObject {
    private let repository: ClothingRepository
    @Published var clothingItems: [ClothingItem] = []
    @Published var isLoading = false
    
    func fetchClothingItems() async throws {
        isLoading = true
        defer { isLoading = false }
        
        clothingItems = try await repository.fetchItems()
    }
    
    func classifyImage(_ image: UIImage) async throws -> ClassificationResult {
        try await withThrowingTaskGroup(of: ClassificationResult.self) { group in
            group.addTask {
                try await self.repository.classifyImage(image)
            }
            return try await group.next() ?? ClassificationResult.empty
        }
    }
}

// ✅ Good - Use actor for data repository
actor ClothingRepository {
    private let networkService: NetworkService
    
    func fetchItems() async throws -> [ClothingItem] {
        try await networkService.fetch(endpoint: .clothingItems)
    }
    
    func classifyImage(_ image: UIImage) async throws -> ClassificationResult {
        let imageData = image.jpegData(compressionQuality: 0.8)
        return try await networkService.upload(data: imageData, endpoint: .classify)
    }
}
```

### ViewModels
```swift
// ✅ Good - MainActor ViewModel with proper async handling
@MainActor
final class WardrobeViewModel: ObservableObject {
    @Published var clothingItems: [ClothingItem] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    private let clothingService: ClothingService
    
    init(clothingService: ClothingService) {
        self.clothingService = clothingService
    }
    
    func task() async {
        do {
            try await clothingService.fetchClothingItems()
            clothingItems = clothingService.clothingItems
        } catch {
            errorMessage = error.localizedDescription
        }
    }
}
```

## SwiftUI Views (iOS 16+) Rules

### Navigation Structure
```swift
// ✅ Good - Use NavigationStack for iOS 16+
struct ContentView: View {
    @StateObject private var authViewModel = AuthenticationViewModel()
    
    var body: some View {
        NavigationStack {
            if authViewModel.isAuthenticated {
                TabView {
                    WardrobeView()
                        .tabItem {
                            Image(systemName: "tshirt")
                            Text("Wardrobe")
                        }
                    
                    OutfitRecommendationView()
                        .tabItem {
                            Image(systemName: "sparkles")
                            Text("Outfits")
                        }
                    
                    WeatherView()
                        .tabItem {
                            Image(systemName: "cloud.sun")
                            Text("Weather")
                        }
                }
            } else {
                AuthenticationView()
            }
        }
        .task {
            await authViewModel.checkAuthenticationStatus()
        }
    }
}
```

### View Implementation Rules
```swift
// ✅ Good - Proper SwiftUI view structure
struct WardrobeView: View {
    @StateObject private var viewModel = WardrobeViewModel()
    @State private var showingAddClothing = false
    @State private var selectedItem: ClothingItem?
    
    var body: some View {
        NavigationStack {
            VStack {
                if viewModel.isLoading {
                    ProgressView("Loading wardrobe...")
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    clothingGrid
                }
            }
            .navigationTitle("My Wardrobe")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Add") {
                        showingAddClothing = true
                    }
                }
            }
            .sheet(isPresented: $showingAddClothing) {
                AddClothingView()
            }
            .sheet(item: $selectedItem) { item in
                ClothingDetailView(item: item)
            }
            .task {
                await viewModel.task()
            }
        }
    }
    
    private var clothingGrid: some View {
        LazyVGrid(columns: [
            GridItem(.adaptive(minimum: 150), spacing: 16)
        ], spacing: 16) {
            ForEach(viewModel.clothingItems) { item in
                ClothingItemCard(item: item) {
                    selectedItem = item
                }
            }
        }
        .padding()
    }
}
```

### Reusable Components
```swift
// ✅ Good - Reusable component with proper styling
struct ClothingItemCard: View {
    let item: ClothingItem
    let onTap: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            AsyncImage(url: item.imageURL) { image in
                image
                    .resizable()
                    .aspectRatio(contentMode: .fill)
            } placeholder: {
                Rectangle()
                    .fill(Color.gray.opacity(0.2))
                    .overlay {
                        Image(systemName: "photo")
                            .foregroundColor(.gray)
                    }
            }
            .frame(height: 150)
            .clipped()
            .cornerRadius(12)
            
            VStack(alignment: .leading, spacing: 4) {
                Text(item.name)
                    .font(.headline)
                    .lineLimit(1)
                
                Text(item.category.rawValue.capitalized)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .background(Color(.systemBackground))
        .cornerRadius(16)
        .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)
        .onTapGesture {
            onTap()
        }
    }
}
```

## Data Models Rules

### Core Models
```swift
// ✅ Good - Codable model with proper structure
struct ClothingItem: Identifiable, Codable, Hashable {
    let id: UUID
    let name: String
    let category: ClothingCategory
    let color: String
    let size: String?
    let brand: String?
    let imageURL: URL?
    let gender: Gender?
    let tags: [String]
    let createdAt: Date
    let updatedAt: Date
    
    enum ClothingCategory: String, CaseIterable, Codable {
        case tops, bottoms, outerwear, shoes, accessories, dresses, activewear
    }
    
    enum Gender: String, CaseIterable, Codable {
        case male, female, unisex
    }
}

struct OutfitRecommendation: Identifiable, Codable {
    let id: UUID
    let items: [ClothingItem]
    let occasion: String
    let weatherConditions: WeatherCondition
    let styleNotes: String
    let createdAt: Date
}

struct WeatherCondition: Codable {
    let temperature: Double
    let condition: String
    let humidity: Double
    let windSpeed: Double
    let description: String
}
```

## Network Layer Rules

### NetworkService Implementation
```swift
// ✅ Good - Modern async/await networking
actor NetworkService {
    private let session: URLSession
    private let baseURL: URL
    
    init(baseURL: URL = URL(string: "https://auarai.com")!) {
        self.baseURL = baseURL
        self.session = URLSession.shared
    }
    
    func fetch<T: Codable>(endpoint: APIEndpoint) async throws -> T {
        let request = try buildRequest(for: endpoint)
        let (data, response) = try await session.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              200...299 ~= httpResponse.statusCode else {
            throw NetworkError.invalidResponse
        }
        
        return try JSONDecoder().decode(T.self, from: data)
    }
    
    func upload<T: Codable>(data: Data, endpoint: APIEndpoint) async throws -> T {
        var request = try buildRequest(for: endpoint)
        request.httpBody = data
        request.setValue("multipart/form-data", forHTTPHeaderField: "Content-Type")
        
        let (responseData, response) = try await session.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              200...299 ~= httpResponse.statusCode else {
            throw NetworkError.uploadFailed
        }
        
        return try JSONDecoder().decode(T.self, from: responseData)
    }
}

enum APIEndpoint {
    case clothingItems
    case classifyImage
    case weatherData(city: String)
    case outfitRecommendation(occasion: String, weather: String)
    
    var path: String {
        switch self {
        case .clothingItems:
            return "/items/"
        case .classifyImage:
            return "/ai/classify-image"
        case .weatherData(let city):
            return "/weather/\(city)"
        case .outfitRecommendation:
            return "/stylist/suggest-outfit"
        }
    }
}
```

## Error Handling Rules

```swift
// ✅ Good - Comprehensive error handling
enum AuarAIError: LocalizedError {
    case networkError(NetworkError)
    case authenticationError(String)
    case imageProcessingError
    case locationError
    case cameraError
    
    var errorDescription: String? {
        switch self {
        case .networkError(let networkError):
            return "Network error: \(networkError.localizedDescription)"
        case .authenticationError(let message):
            return "Authentication failed: \(message)"
        case .imageProcessingError:
            return "Failed to process image"
        case .locationError:
            return "Location access denied"
        case .cameraError:
            return "Camera access denied"
        }
    }
}
```

## Testing Rules

### Unit Tests
```swift
// ✅ Good - Async test structure
@MainActor
final class WardrobeViewModelTests: XCTestCase {
    private var sut: WardrobeViewModel!
    private var mockClothingService: MockClothingService!
    
    override func setUp() async throws {
        mockClothingService = MockClothingService()
        sut = WardrobeViewModel(clothingService: mockClothingService)
    }
    
    func testFetchClothingItems_Success() async throws {
        // Given
        let expectedItems = [ClothingItem.mock]
        mockClothingService.clothingItems = expectedItems
        
        // When
        await sut.task()
        
        // Then
        XCTAssertEqual(sut.clothingItems, expectedItems)
        XCTAssertFalse(sut.isLoading)
        XCTAssertNil(sut.errorMessage)
    }
}
```

## Performance & Memory Rules

1. **Use `@State` for local view state only**
2. **Use `@StateObject` for view-owned objects**
3. **Use `@ObservedObject` for externally-owned objects**
4. **Use `@EnvironmentObject` for shared app state**
5. **Always use `LazyVGrid`/`LazyHGrid` for large collections**
6. **Implement proper image caching for wardrobe photos**
7. **Use `Task` for async operations in views**
8. **Cancel tasks in `onDisappear` when needed**

## Security Rules

1. **Never store sensitive data in UserDefaults**
2. **Use Keychain for authentication tokens**
3. **Validate all user inputs**
4. **Use proper HTTPS for all network requests**
5. **Implement proper photo permissions handling**
6. **Use Face ID/Touch ID for sensitive operations when available**

## AI Integration Rules

1. **Use Vision framework for local image classification when possible**
2. **Implement proper error handling for AI service failures**
3. **Provide fallback options when AI services are unavailable**
4. **Cache AI results to improve performance**
5. **Implement proper loading states for AI operations**

Remember: Always follow iOS Human Interface Guidelines and ensure your app works seamlessly across different iPhone sizes and orientations. 